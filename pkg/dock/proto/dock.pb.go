// Code generated by protoc-gen-go. DO NOT EDIT.
// source: dock.proto

/*
Package proto is a generated protocol buffer package.

It is generated from these files:
	dock.proto

It has these top-level messages:
	CreateVolumeOpts
	DeleteVolumeOpts
	ExtendVolumeOpts
	CreateVolumeSnapshotOpts
	DeleteVolumeSnapshotOpts
	CreateAttachmentOpts
	DeleteAttachmentOpts
	HostInfo
	VolumeData
	CreateReplicationOpts
	DeleteReplicationOpts
	EnableReplicationOpts
	DisableReplicationOpts
	FailoverReplicationOpts
	GenericResponse
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto1.ProtoPackageIsVersion2 // please upgrade the proto package

// CreateVolumeOpts is a structure which indicates all required properties
// for creating a volume.
type CreateVolumeOpts struct {
	// The uuid of the volume, optional when creating.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The name of the volume, required.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The requested capacity of the volume, required.
	Size int64 `protobuf:"varint,3,opt,name=size" json:"size,omitempty"`
	// The description of the volume, optional.
	Description string `protobuf:"bytes,4,opt,name=description" json:"description,omitempty"`
	// When create volume from snapshot, this field is required.
	SnapshotId string `protobuf:"bytes,5,opt,name=snapshotId" json:"snapshotId,omitempty"`
	// The locality that volume belongs to, required.
	AvailabilityZone string `protobuf:"bytes,6,opt,name=availabilityZone" json:"availabilityZone,omitempty"`
	// The service level that volume belongs to, required.
	ProfileId string `protobuf:"bytes,7,opt,name=profileId" json:"profileId,omitempty"`
	// The uuid of the pool on which volume will be created, required.
	PoolId string `protobuf:"bytes,8,opt,name=poolId" json:"poolId,omitempty"`
	// The name of the pool on which volume will be created, required.
	PoolName string `protobuf:"bytes,9,opt,name=poolName" json:"poolName,omitempty"`
	// The metadata of the volume, optional.
	Metadata map[string]string `protobuf:"bytes,10,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The dock infomation on which the request will be executed
	DockId string `protobuf:"bytes,11,opt,name=dockId" json:"dockId,omitempty"`
	// The storage driver type.
	DriverName string `protobuf:"bytes,12,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,13,opt,name=context" json:"context,omitempty"`
	// The replication driver data
	ReplicationDriverData map[string]string `protobuf:"bytes,14,rep,name=replicationDriverData" json:"replicationDriverData,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The uuid of replication
	ReplicationId string `protobuf:"bytes,15,opt,name=replicationId" json:"replicationId,omitempty"`
}

func (m *CreateVolumeOpts) Reset()                    { *m = CreateVolumeOpts{} }
func (m *CreateVolumeOpts) String() string            { return proto1.CompactTextString(m) }
func (*CreateVolumeOpts) ProtoMessage()               {}
func (*CreateVolumeOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *CreateVolumeOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CreateVolumeOpts) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateVolumeOpts) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *CreateVolumeOpts) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CreateVolumeOpts) GetSnapshotId() string {
	if m != nil {
		return m.SnapshotId
	}
	return ""
}

func (m *CreateVolumeOpts) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}

func (m *CreateVolumeOpts) GetProfileId() string {
	if m != nil {
		return m.ProfileId
	}
	return ""
}

func (m *CreateVolumeOpts) GetPoolId() string {
	if m != nil {
		return m.PoolId
	}
	return ""
}

func (m *CreateVolumeOpts) GetPoolName() string {
	if m != nil {
		return m.PoolName
	}
	return ""
}

func (m *CreateVolumeOpts) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CreateVolumeOpts) GetDockId() string {
	if m != nil {
		return m.DockId
	}
	return ""
}

func (m *CreateVolumeOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *CreateVolumeOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

func (m *CreateVolumeOpts) GetReplicationDriverData() map[string]string {
	if m != nil {
		return m.ReplicationDriverData
	}
	return nil
}

func (m *CreateVolumeOpts) GetReplicationId() string {
	if m != nil {
		return m.ReplicationId
	}
	return ""
}

// DeleteVolumeOpts is a structure which indicates all required properties
// for deleting a volume.
type DeleteVolumeOpts struct {
	// The uuid of the volume, required.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The metadata of the volume, optional.
	Metadata map[string]string `protobuf:"bytes,2,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The dock infomation on which the request will be executed.
	DockId string `protobuf:"bytes,3,opt,name=dockId" json:"dockId,omitempty"`
	// The storage driver type.
	DriverName string `protobuf:"bytes,4,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,5,opt,name=context" json:"context,omitempty"`
}

func (m *DeleteVolumeOpts) Reset()                    { *m = DeleteVolumeOpts{} }
func (m *DeleteVolumeOpts) String() string            { return proto1.CompactTextString(m) }
func (*DeleteVolumeOpts) ProtoMessage()               {}
func (*DeleteVolumeOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *DeleteVolumeOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DeleteVolumeOpts) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *DeleteVolumeOpts) GetDockId() string {
	if m != nil {
		return m.DockId
	}
	return ""
}

func (m *DeleteVolumeOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *DeleteVolumeOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

// ExtendVolumeOpts is a structure which indicates all required properties
// for Extending a volume.
type ExtendVolumeOpts struct {
	// The uuid of the volume, optional when creating.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The name of the volume, required.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The requested capacity of the volume, required.
	Size int64 `protobuf:"varint,3,opt,name=size" json:"size,omitempty"`
	// The description of the volume, optional.
	Description string `protobuf:"bytes,4,opt,name=description" json:"description,omitempty"`
	// When create volume from snapshot, this field is required.
	SnapshotId string `protobuf:"bytes,5,opt,name=snapshotId" json:"snapshotId,omitempty"`
	// The locality that volume belongs to, required.
	AvailabilityZone string `protobuf:"bytes,6,opt,name=availabilityZone" json:"availabilityZone,omitempty"`
	// The service level that volume belongs to, required.
	ProfileId string `protobuf:"bytes,7,opt,name=profileId" json:"profileId,omitempty"`
	// The uuid of the pool on which volume will be created, required.
	PoolId string `protobuf:"bytes,8,opt,name=poolId" json:"poolId,omitempty"`
	// The name of the pool on which volume will be created, required.
	PoolName string `protobuf:"bytes,9,opt,name=poolName" json:"poolName,omitempty"`
	// The metadata of the volume, optional.
	Metadata map[string]string `protobuf:"bytes,10,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The dock infomation on which the request will be executed
	DockId string `protobuf:"bytes,11,opt,name=dockId" json:"dockId,omitempty"`
	// The storage driver type.
	DriverName string `protobuf:"bytes,12,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,13,opt,name=context" json:"context,omitempty"`
}

func (m *ExtendVolumeOpts) Reset()                    { *m = ExtendVolumeOpts{} }
func (m *ExtendVolumeOpts) String() string            { return proto1.CompactTextString(m) }
func (*ExtendVolumeOpts) ProtoMessage()               {}
func (*ExtendVolumeOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ExtendVolumeOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ExtendVolumeOpts) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ExtendVolumeOpts) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *ExtendVolumeOpts) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ExtendVolumeOpts) GetSnapshotId() string {
	if m != nil {
		return m.SnapshotId
	}
	return ""
}

func (m *ExtendVolumeOpts) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}

func (m *ExtendVolumeOpts) GetProfileId() string {
	if m != nil {
		return m.ProfileId
	}
	return ""
}

func (m *ExtendVolumeOpts) GetPoolId() string {
	if m != nil {
		return m.PoolId
	}
	return ""
}

func (m *ExtendVolumeOpts) GetPoolName() string {
	if m != nil {
		return m.PoolName
	}
	return ""
}

func (m *ExtendVolumeOpts) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *ExtendVolumeOpts) GetDockId() string {
	if m != nil {
		return m.DockId
	}
	return ""
}

func (m *ExtendVolumeOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *ExtendVolumeOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

// CreateVolumeSnapshotOpts is a structure which indicates all required
// properties for creating a volume snapshot.
type CreateVolumeSnapshotOpts struct {
	// The uuid of the volume snapshot, optional.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The name of the volume snapshot, required.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The size of the volume that snapshot belongs to, required.
	Size int64 `protobuf:"varint,3,opt,name=size" json:"size,omitempty"`
	// The description of the volume snapshot, optional.
	Description string `protobuf:"bytes,4,opt,name=description" json:"description,omitempty"`
	// The uuid of the volume that snapshot belongs to, required.
	VolumeId string `protobuf:"bytes,5,opt,name=volumeId" json:"volumeId,omitempty"`
	// The metadata of the volume snapshot, optional.
	Metadata map[string]string `protobuf:"bytes,6,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The dock infomation on which the request will be executed
	DockId string `protobuf:"bytes,7,opt,name=dockId" json:"dockId,omitempty"`
	// The storage driver type.
	DriverName string `protobuf:"bytes,8,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,9,opt,name=context" json:"context,omitempty"`
}

func (m *CreateVolumeSnapshotOpts) Reset()                    { *m = CreateVolumeSnapshotOpts{} }
func (m *CreateVolumeSnapshotOpts) String() string            { return proto1.CompactTextString(m) }
func (*CreateVolumeSnapshotOpts) ProtoMessage()               {}
func (*CreateVolumeSnapshotOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *CreateVolumeSnapshotOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CreateVolumeSnapshotOpts) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateVolumeSnapshotOpts) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *CreateVolumeSnapshotOpts) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CreateVolumeSnapshotOpts) GetVolumeId() string {
	if m != nil {
		return m.VolumeId
	}
	return ""
}

func (m *CreateVolumeSnapshotOpts) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CreateVolumeSnapshotOpts) GetDockId() string {
	if m != nil {
		return m.DockId
	}
	return ""
}

func (m *CreateVolumeSnapshotOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *CreateVolumeSnapshotOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

// DeleteVolumeSnapshotOpts is a structure which indicates all required
// properties for deleting a volume snapshot.
type DeleteVolumeSnapshotOpts struct {
	// The uuid of the volume snapshot, required.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The uuid of the volume that snapshot belongs to, required.
	VolumeId string `protobuf:"bytes,2,opt,name=volumeId" json:"volumeId,omitempty"`
	// The metadata of the volume snapshot, optional.
	Metadata map[string]string `protobuf:"bytes,3,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The dock infomation on which the request will be executed
	DockId string `protobuf:"bytes,4,opt,name=dockId" json:"dockId,omitempty"`
	// The storage driver type.
	DriverName string `protobuf:"bytes,5,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,6,opt,name=context" json:"context,omitempty"`
}

func (m *DeleteVolumeSnapshotOpts) Reset()                    { *m = DeleteVolumeSnapshotOpts{} }
func (m *DeleteVolumeSnapshotOpts) String() string            { return proto1.CompactTextString(m) }
func (*DeleteVolumeSnapshotOpts) ProtoMessage()               {}
func (*DeleteVolumeSnapshotOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *DeleteVolumeSnapshotOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DeleteVolumeSnapshotOpts) GetVolumeId() string {
	if m != nil {
		return m.VolumeId
	}
	return ""
}

func (m *DeleteVolumeSnapshotOpts) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *DeleteVolumeSnapshotOpts) GetDockId() string {
	if m != nil {
		return m.DockId
	}
	return ""
}

func (m *DeleteVolumeSnapshotOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *DeleteVolumeSnapshotOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

// CreateAttachmentOpts is a structure which indicates all required
// properties for creating a volume attachment.
type CreateAttachmentOpts struct {
	// The uuid of the volume attachment, optional.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The uuid of the volume, required.
	VolumeId string `protobuf:"bytes,2,opt,name=volumeId" json:"volumeId,omitempty"`
	// This field indicates if the volume is attached locally, optional.
	DoLocalAttach bool `protobuf:"varint,3,opt,name=doLocalAttach" json:"doLocalAttach,omitempty"`
	// This field indicates if the volume is attached multiple times, optional.
	MultiPath bool `protobuf:"varint,4,opt,name=multiPath" json:"multiPath,omitempty"`
	// The infomation of the host node on which the volume will be attached.
	HostInfo *HostInfo `protobuf:"bytes,5,opt,name=hostInfo" json:"hostInfo,omitempty"`
	// The metadata of the volume attachment, optional.
	Metadata map[string]string `protobuf:"bytes,6,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The dock infomation on which the request will be executed
	DockId string `protobuf:"bytes,7,opt,name=dockId" json:"dockId,omitempty"`
	// The storage driver type.
	DriverName string `protobuf:"bytes,8,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,9,opt,name=context" json:"context,omitempty"`
}

func (m *CreateAttachmentOpts) Reset()                    { *m = CreateAttachmentOpts{} }
func (m *CreateAttachmentOpts) String() string            { return proto1.CompactTextString(m) }
func (*CreateAttachmentOpts) ProtoMessage()               {}
func (*CreateAttachmentOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *CreateAttachmentOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CreateAttachmentOpts) GetVolumeId() string {
	if m != nil {
		return m.VolumeId
	}
	return ""
}

func (m *CreateAttachmentOpts) GetDoLocalAttach() bool {
	if m != nil {
		return m.DoLocalAttach
	}
	return false
}

func (m *CreateAttachmentOpts) GetMultiPath() bool {
	if m != nil {
		return m.MultiPath
	}
	return false
}

func (m *CreateAttachmentOpts) GetHostInfo() *HostInfo {
	if m != nil {
		return m.HostInfo
	}
	return nil
}

func (m *CreateAttachmentOpts) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CreateAttachmentOpts) GetDockId() string {
	if m != nil {
		return m.DockId
	}
	return ""
}

func (m *CreateAttachmentOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *CreateAttachmentOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

// DeleteAttachmentOpts is a structure which indicates all required
// properties for deleting a volume attachment.
type DeleteAttachmentOpts struct {
	// The uuid of the volume attachment, optional.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The uuid of the volume, required.
	VolumeId string `protobuf:"bytes,2,opt,name=volumeId" json:"volumeId,omitempty"`
	// The infomation of the host node on which the volume will be attached.
	HostInfo *HostInfo `protobuf:"bytes,3,opt,name=hostInfo" json:"hostInfo,omitempty"`
	// The metadata of the volume attachment, optional.
	Metadata map[string]string `protobuf:"bytes,4,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The dock infomation on which the request will be executed
	DockId string `protobuf:"bytes,5,opt,name=dockId" json:"dockId,omitempty"`
	// The storage driver type.
	DriverName string `protobuf:"bytes,6,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,7,opt,name=context" json:"context,omitempty"`
}

func (m *DeleteAttachmentOpts) Reset()                    { *m = DeleteAttachmentOpts{} }
func (m *DeleteAttachmentOpts) String() string            { return proto1.CompactTextString(m) }
func (*DeleteAttachmentOpts) ProtoMessage()               {}
func (*DeleteAttachmentOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *DeleteAttachmentOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DeleteAttachmentOpts) GetVolumeId() string {
	if m != nil {
		return m.VolumeId
	}
	return ""
}

func (m *DeleteAttachmentOpts) GetHostInfo() *HostInfo {
	if m != nil {
		return m.HostInfo
	}
	return nil
}

func (m *DeleteAttachmentOpts) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *DeleteAttachmentOpts) GetDockId() string {
	if m != nil {
		return m.DockId
	}
	return ""
}

func (m *DeleteAttachmentOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *DeleteAttachmentOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

type HostInfo struct {
	// The platform of the host, such as "x86_64"
	Platform string `protobuf:"bytes,1,opt,name=platform" json:"platform,omitempty"`
	// The type of OS, such as "linux","windows", etc.
	OsType string `protobuf:"bytes,2,opt,name=osType" json:"osType,omitempty"`
	// The name of the host
	Host string `protobuf:"bytes,3,opt,name=host" json:"host,omitempty"`
	// The ip address of the host
	Ip string `protobuf:"bytes,4,opt,name=ip" json:"ip,omitempty"`
	// The initiator infomation, such as: "iqn.2017.com.redhat:e08039b48d5c"
	Initiator string `protobuf:"bytes,5,opt,name=initiator" json:"initiator,omitempty"`
}

func (m *HostInfo) Reset()                    { *m = HostInfo{} }
func (m *HostInfo) String() string            { return proto1.CompactTextString(m) }
func (*HostInfo) ProtoMessage()               {}
func (*HostInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *HostInfo) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *HostInfo) GetOsType() string {
	if m != nil {
		return m.OsType
	}
	return ""
}

func (m *HostInfo) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *HostInfo) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *HostInfo) GetInitiator() string {
	if m != nil {
		return m.Initiator
	}
	return ""
}

type VolumeData struct {
	Data map[string]string `protobuf:"bytes,1,rep,name=data" json:"data,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *VolumeData) Reset()                    { *m = VolumeData{} }
func (m *VolumeData) String() string            { return proto1.CompactTextString(m) }
func (*VolumeData) ProtoMessage()               {}
func (*VolumeData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *VolumeData) GetData() map[string]string {
	if m != nil {
		return m.Data
	}
	return nil
}

// CreateReplicationOpts is a structure which indicates all required properties
// for creating a replication.
// NOTE: Need to figure out how to handle more than 2 sites.
type CreateReplicationOpts struct {
	// The uuid of the replication, optional when creating.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The name of the replication, optional.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The description of the replication, optional.
	Description string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	// The uuid of the primary volume. This field is required.
	PrimaryVolumeId string `protobuf:"bytes,4,opt,name=primaryVolumeId" json:"primaryVolumeId,omitempty"`
	// The uuid of the secondary volume. This field is required.
	SecondaryVolumeId string `protobuf:"bytes,5,opt,name=secondaryVolumeId" json:"secondaryVolumeId,omitempty"`
	// The dock infomation on which the request will be executed
	AvailabilityZone string `protobuf:"bytes,6,opt,name=availabilityZone" json:"availabilityZone,omitempty"`
	// The service level that volume belongs to, required.
	ProfileId string `protobuf:"bytes,7,opt,name=profileId" json:"profileId,omitempty"`
	// The uuid of the pool on which volume will be created, required.
	PoolId string `protobuf:"bytes,8,opt,name=poolId" json:"poolId,omitempty"`
	// The name of the pool on which volume will be created, required.
	PoolName string `protobuf:"bytes,9,opt,name=poolName" json:"poolName,omitempty"`
	// The metadata of the primary replication, optional.
	PrimaryReplicationDriverData map[string]string `protobuf:"bytes,11,rep,name=primaryReplicationDriverData" json:"primaryReplicationDriverData,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The metadata of the seondary replication, optional.
	SecondaryReplicationDriverData map[string]string `protobuf:"bytes,12,rep,name=secondaryReplicationDriverData" json:"secondaryReplicationDriverData,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The dock id.
	DockId string `protobuf:"bytes,13,opt,name=dockId" json:"dockId,omitempty"`
	// The replication driver type.
	DriverName string `protobuf:"bytes,14,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,15,opt,name=context" json:"context,omitempty"`
	// Whether is primary replication
	IsPrimary bool `protobuf:"varint,16,opt,name=isPrimary" json:"isPrimary,omitempty"`
	// The replication metadata
	Metadata map[string]string `protobuf:"bytes,17,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The volume data list
	VolumeDataList []*VolumeData `protobuf:"bytes,18,rep,name=volumeDataList" json:"volumeDataList,omitempty"`
}

func (m *CreateReplicationOpts) Reset()                    { *m = CreateReplicationOpts{} }
func (m *CreateReplicationOpts) String() string            { return proto1.CompactTextString(m) }
func (*CreateReplicationOpts) ProtoMessage()               {}
func (*CreateReplicationOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *CreateReplicationOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CreateReplicationOpts) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateReplicationOpts) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CreateReplicationOpts) GetPrimaryVolumeId() string {
	if m != nil {
		return m.PrimaryVolumeId
	}
	return ""
}

func (m *CreateReplicationOpts) GetSecondaryVolumeId() string {
	if m != nil {
		return m.SecondaryVolumeId
	}
	return ""
}

func (m *CreateReplicationOpts) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}

func (m *CreateReplicationOpts) GetProfileId() string {
	if m != nil {
		return m.ProfileId
	}
	return ""
}

func (m *CreateReplicationOpts) GetPoolId() string {
	if m != nil {
		return m.PoolId
	}
	return ""
}

func (m *CreateReplicationOpts) GetPoolName() string {
	if m != nil {
		return m.PoolName
	}
	return ""
}

func (m *CreateReplicationOpts) GetPrimaryReplicationDriverData() map[string]string {
	if m != nil {
		return m.PrimaryReplicationDriverData
	}
	return nil
}

func (m *CreateReplicationOpts) GetSecondaryReplicationDriverData() map[string]string {
	if m != nil {
		return m.SecondaryReplicationDriverData
	}
	return nil
}

func (m *CreateReplicationOpts) GetDockId() string {
	if m != nil {
		return m.DockId
	}
	return ""
}

func (m *CreateReplicationOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *CreateReplicationOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

func (m *CreateReplicationOpts) GetIsPrimary() bool {
	if m != nil {
		return m.IsPrimary
	}
	return false
}

func (m *CreateReplicationOpts) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CreateReplicationOpts) GetVolumeDataList() []*VolumeData {
	if m != nil {
		return m.VolumeDataList
	}
	return nil
}

// Delete ReplicationOpts is a structure which indicates all required properties
// for deleting a replication.
// NOTE: Need to figure out how to handle more than 2 sites.
type DeleteReplicationOpts struct {
	// The uuid of the replication, optional when creating.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The name of the replication, optional.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The description of the replication, optional.
	Description string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	// The uuid of the primary volume. This field is required.
	PrimaryVolumeId string `protobuf:"bytes,4,opt,name=primaryVolumeId" json:"primaryVolumeId,omitempty"`
	// The uuid of the secondary volume. This field is required.
	SecondaryVolumeId string `protobuf:"bytes,5,opt,name=secondaryVolumeId" json:"secondaryVolumeId,omitempty"`
	// The dock infomation on which the request will be executed
	AvailabilityZone string `protobuf:"bytes,6,opt,name=availabilityZone" json:"availabilityZone,omitempty"`
	// The service level that volume belongs to, required.
	ProfileId string `protobuf:"bytes,7,opt,name=profileId" json:"profileId,omitempty"`
	// The uuid of the pool on which volume will be created, required.
	PoolId string `protobuf:"bytes,8,opt,name=poolId" json:"poolId,omitempty"`
	// The name of the pool on which volume will be created, required.
	PoolName string `protobuf:"bytes,9,opt,name=poolName" json:"poolName,omitempty"`
	// The metadata of the primary replication, optional.
	PrimaryReplicationDriverData map[string]string `protobuf:"bytes,11,rep,name=primaryReplicationDriverData" json:"primaryReplicationDriverData,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The metadata of the seondary replication, optional.
	SecondaryReplicationDriverData map[string]string `protobuf:"bytes,12,rep,name=secondaryReplicationDriverData" json:"secondaryReplicationDriverData,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The dock id.
	DockId string `protobuf:"bytes,13,opt,name=dockId" json:"dockId,omitempty"`
	// The replication driver type.
	DriverName string `protobuf:"bytes,14,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,15,opt,name=context" json:"context,omitempty"`
}

func (m *DeleteReplicationOpts) Reset()                    { *m = DeleteReplicationOpts{} }
func (m *DeleteReplicationOpts) String() string            { return proto1.CompactTextString(m) }
func (*DeleteReplicationOpts) ProtoMessage()               {}
func (*DeleteReplicationOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *DeleteReplicationOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DeleteReplicationOpts) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DeleteReplicationOpts) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *DeleteReplicationOpts) GetPrimaryVolumeId() string {
	if m != nil {
		return m.PrimaryVolumeId
	}
	return ""
}

func (m *DeleteReplicationOpts) GetSecondaryVolumeId() string {
	if m != nil {
		return m.SecondaryVolumeId
	}
	return ""
}

func (m *DeleteReplicationOpts) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}

func (m *DeleteReplicationOpts) GetProfileId() string {
	if m != nil {
		return m.ProfileId
	}
	return ""
}

func (m *DeleteReplicationOpts) GetPoolId() string {
	if m != nil {
		return m.PoolId
	}
	return ""
}

func (m *DeleteReplicationOpts) GetPoolName() string {
	if m != nil {
		return m.PoolName
	}
	return ""
}

func (m *DeleteReplicationOpts) GetPrimaryReplicationDriverData() map[string]string {
	if m != nil {
		return m.PrimaryReplicationDriverData
	}
	return nil
}

func (m *DeleteReplicationOpts) GetSecondaryReplicationDriverData() map[string]string {
	if m != nil {
		return m.SecondaryReplicationDriverData
	}
	return nil
}

func (m *DeleteReplicationOpts) GetDockId() string {
	if m != nil {
		return m.DockId
	}
	return ""
}

func (m *DeleteReplicationOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *DeleteReplicationOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

// Delete ReplicationOpts is a structure which indicates all required properties
type EnableReplicationOpts struct {
	// The uuid of the replication, optional when creating.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The name of the replication, optional.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The description of the replication, optional.
	Description string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	// The uuid of the primary volume. This field is required.
	PrimaryVolumeId string `protobuf:"bytes,4,opt,name=primaryVolumeId" json:"primaryVolumeId,omitempty"`
	// The uuid of the secondary volume. This field is required.
	SecondaryVolumeId string `protobuf:"bytes,5,opt,name=secondaryVolumeId" json:"secondaryVolumeId,omitempty"`
	// The dock infomation on which the request will be executed
	AvailabilityZone string `protobuf:"bytes,6,opt,name=availabilityZone" json:"availabilityZone,omitempty"`
	// The service level that volume belongs to, required.
	ProfileId string `protobuf:"bytes,7,opt,name=profileId" json:"profileId,omitempty"`
	// The uuid of the pool on which volume will be created, required.
	PoolId string `protobuf:"bytes,8,opt,name=poolId" json:"poolId,omitempty"`
	// The name of the pool on which volume will be created, required.
	PoolName string `protobuf:"bytes,9,opt,name=poolName" json:"poolName,omitempty"`
	// The metadata of the primary replication, optional.
	PrimaryReplicationDriverData map[string]string `protobuf:"bytes,11,rep,name=primaryReplicationDriverData" json:"primaryReplicationDriverData,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The metadata of the seondary replication, optional.
	SecondaryReplicationDriverData map[string]string `protobuf:"bytes,12,rep,name=secondaryReplicationDriverData" json:"secondaryReplicationDriverData,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The dock id.
	DockId string `protobuf:"bytes,13,opt,name=dockId" json:"dockId,omitempty"`
	// The replication driver type.
	DriverName string `protobuf:"bytes,14,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,15,opt,name=context" json:"context,omitempty"`
}

func (m *EnableReplicationOpts) Reset()                    { *m = EnableReplicationOpts{} }
func (m *EnableReplicationOpts) String() string            { return proto1.CompactTextString(m) }
func (*EnableReplicationOpts) ProtoMessage()               {}
func (*EnableReplicationOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *EnableReplicationOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *EnableReplicationOpts) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EnableReplicationOpts) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *EnableReplicationOpts) GetPrimaryVolumeId() string {
	if m != nil {
		return m.PrimaryVolumeId
	}
	return ""
}

func (m *EnableReplicationOpts) GetSecondaryVolumeId() string {
	if m != nil {
		return m.SecondaryVolumeId
	}
	return ""
}

func (m *EnableReplicationOpts) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}

func (m *EnableReplicationOpts) GetProfileId() string {
	if m != nil {
		return m.ProfileId
	}
	return ""
}

func (m *EnableReplicationOpts) GetPoolId() string {
	if m != nil {
		return m.PoolId
	}
	return ""
}

func (m *EnableReplicationOpts) GetPoolName() string {
	if m != nil {
		return m.PoolName
	}
	return ""
}

func (m *EnableReplicationOpts) GetPrimaryReplicationDriverData() map[string]string {
	if m != nil {
		return m.PrimaryReplicationDriverData
	}
	return nil
}

func (m *EnableReplicationOpts) GetSecondaryReplicationDriverData() map[string]string {
	if m != nil {
		return m.SecondaryReplicationDriverData
	}
	return nil
}

func (m *EnableReplicationOpts) GetDockId() string {
	if m != nil {
		return m.DockId
	}
	return ""
}

func (m *EnableReplicationOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *EnableReplicationOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

// Delete ReplicationOpts is a structure which indicates all required properties
type DisableReplicationOpts struct {
	// The uuid of the replication, optional when creating.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The name of the replication, optional.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The description of the replication, optional.
	Description string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	// The uuid of the primary volume. This field is required.
	PrimaryVolumeId string `protobuf:"bytes,4,opt,name=primaryVolumeId" json:"primaryVolumeId,omitempty"`
	// The uuid of the secondary volume. This field is required.
	SecondaryVolumeId string `protobuf:"bytes,5,opt,name=secondaryVolumeId" json:"secondaryVolumeId,omitempty"`
	// The dock infomation on which the request will be executed
	AvailabilityZone string `protobuf:"bytes,6,opt,name=availabilityZone" json:"availabilityZone,omitempty"`
	// The service level that volume belongs to, required.
	ProfileId string `protobuf:"bytes,7,opt,name=profileId" json:"profileId,omitempty"`
	// The uuid of the pool on which volume will be created, required.
	PoolId string `protobuf:"bytes,8,opt,name=poolId" json:"poolId,omitempty"`
	// The name of the pool on which volume will be created, required.
	PoolName string `protobuf:"bytes,9,opt,name=poolName" json:"poolName,omitempty"`
	// The metadata of the primary replication, optional.
	PrimaryReplicationDriverData map[string]string `protobuf:"bytes,11,rep,name=primaryReplicationDriverData" json:"primaryReplicationDriverData,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The metadata of the seondary replication, optional.
	SecondaryReplicationDriverData map[string]string `protobuf:"bytes,12,rep,name=secondaryReplicationDriverData" json:"secondaryReplicationDriverData,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The dock id.
	DockId string `protobuf:"bytes,13,opt,name=dockId" json:"dockId,omitempty"`
	// The replication driver type.
	DriverName string `protobuf:"bytes,14,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,15,opt,name=context" json:"context,omitempty"`
}

func (m *DisableReplicationOpts) Reset()                    { *m = DisableReplicationOpts{} }
func (m *DisableReplicationOpts) String() string            { return proto1.CompactTextString(m) }
func (*DisableReplicationOpts) ProtoMessage()               {}
func (*DisableReplicationOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *DisableReplicationOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DisableReplicationOpts) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DisableReplicationOpts) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *DisableReplicationOpts) GetPrimaryVolumeId() string {
	if m != nil {
		return m.PrimaryVolumeId
	}
	return ""
}

func (m *DisableReplicationOpts) GetSecondaryVolumeId() string {
	if m != nil {
		return m.SecondaryVolumeId
	}
	return ""
}

func (m *DisableReplicationOpts) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}

func (m *DisableReplicationOpts) GetProfileId() string {
	if m != nil {
		return m.ProfileId
	}
	return ""
}

func (m *DisableReplicationOpts) GetPoolId() string {
	if m != nil {
		return m.PoolId
	}
	return ""
}

func (m *DisableReplicationOpts) GetPoolName() string {
	if m != nil {
		return m.PoolName
	}
	return ""
}

func (m *DisableReplicationOpts) GetPrimaryReplicationDriverData() map[string]string {
	if m != nil {
		return m.PrimaryReplicationDriverData
	}
	return nil
}

func (m *DisableReplicationOpts) GetSecondaryReplicationDriverData() map[string]string {
	if m != nil {
		return m.SecondaryReplicationDriverData
	}
	return nil
}

func (m *DisableReplicationOpts) GetDockId() string {
	if m != nil {
		return m.DockId
	}
	return ""
}

func (m *DisableReplicationOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *DisableReplicationOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

// Delete ReplicationOpts is a structure which indicates all required properties
type FailoverReplicationOpts struct {
	// The uuid of the replication, optional when creating.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The name of the replication, optional.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The description of the replication, optional.
	Description string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	// The uuid of the primary volume. This field is required.
	PrimaryVolumeId string `protobuf:"bytes,4,opt,name=primaryVolumeId" json:"primaryVolumeId,omitempty"`
	// The uuid of the secondary volume. This field is required.
	SecondaryVolumeId string `protobuf:"bytes,5,opt,name=secondaryVolumeId" json:"secondaryVolumeId,omitempty"`
	// The dock infomation on which the request will be executed
	AvailabilityZone string `protobuf:"bytes,6,opt,name=availabilityZone" json:"availabilityZone,omitempty"`
	// The service level that volume belongs to, required.
	ProfileId string `protobuf:"bytes,7,opt,name=profileId" json:"profileId,omitempty"`
	// The uuid of the pool on which volume will be created, required.
	PoolId string `protobuf:"bytes,8,opt,name=poolId" json:"poolId,omitempty"`
	// The name of the pool on which volume will be created, required.
	PoolName string `protobuf:"bytes,9,opt,name=poolName" json:"poolName,omitempty"`
	// The metadata of the primary replication, optional.
	PrimaryReplicationDriverData map[string]string `protobuf:"bytes,11,rep,name=primaryReplicationDriverData" json:"primaryReplicationDriverData,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The metadata of the seondary replication, optional.
	SecondaryReplicationDriverData map[string]string `protobuf:"bytes,12,rep,name=secondaryReplicationDriverData" json:"secondaryReplicationDriverData,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The dock id.
	DockId string `protobuf:"bytes,13,opt,name=dockId" json:"dockId,omitempty"`
	// The replication driver type.
	DriverName string `protobuf:"bytes,14,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,15,opt,name=context" json:"context,omitempty"`
	// Allow attached volume
	AllowAttachedVolume bool `protobuf:"varint,16,opt,name=allowAttachedVolume" json:"allowAttachedVolume,omitempty"`
	// The secondary backend id.
	SecondaryBackendId string `protobuf:"bytes,17,opt,name=secondaryBackendId" json:"secondaryBackendId,omitempty"`
}

func (m *FailoverReplicationOpts) Reset()                    { *m = FailoverReplicationOpts{} }
func (m *FailoverReplicationOpts) String() string            { return proto1.CompactTextString(m) }
func (*FailoverReplicationOpts) ProtoMessage()               {}
func (*FailoverReplicationOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *FailoverReplicationOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *FailoverReplicationOpts) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FailoverReplicationOpts) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *FailoverReplicationOpts) GetPrimaryVolumeId() string {
	if m != nil {
		return m.PrimaryVolumeId
	}
	return ""
}

func (m *FailoverReplicationOpts) GetSecondaryVolumeId() string {
	if m != nil {
		return m.SecondaryVolumeId
	}
	return ""
}

func (m *FailoverReplicationOpts) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}

func (m *FailoverReplicationOpts) GetProfileId() string {
	if m != nil {
		return m.ProfileId
	}
	return ""
}

func (m *FailoverReplicationOpts) GetPoolId() string {
	if m != nil {
		return m.PoolId
	}
	return ""
}

func (m *FailoverReplicationOpts) GetPoolName() string {
	if m != nil {
		return m.PoolName
	}
	return ""
}

func (m *FailoverReplicationOpts) GetPrimaryReplicationDriverData() map[string]string {
	if m != nil {
		return m.PrimaryReplicationDriverData
	}
	return nil
}

func (m *FailoverReplicationOpts) GetSecondaryReplicationDriverData() map[string]string {
	if m != nil {
		return m.SecondaryReplicationDriverData
	}
	return nil
}

func (m *FailoverReplicationOpts) GetDockId() string {
	if m != nil {
		return m.DockId
	}
	return ""
}

func (m *FailoverReplicationOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *FailoverReplicationOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

func (m *FailoverReplicationOpts) GetAllowAttachedVolume() bool {
	if m != nil {
		return m.AllowAttachedVolume
	}
	return false
}

func (m *FailoverReplicationOpts) GetSecondaryBackendId() string {
	if m != nil {
		return m.SecondaryBackendId
	}
	return ""
}

// Generic response, it return:
// 1. Return result with message when create/update resource successfully.
// 2. Return result without message when delete resource successfully.
// 3. Return Error with error code and message when operate unsuccessfully.
type GenericResponse struct {
	// Types that are valid to be assigned to Reply:
	//	*GenericResponse_Result_
	//	*GenericResponse_Error_
	Reply isGenericResponse_Reply `protobuf_oneof:"reply"`
}

func (m *GenericResponse) Reset()                    { *m = GenericResponse{} }
func (m *GenericResponse) String() string            { return proto1.CompactTextString(m) }
func (*GenericResponse) ProtoMessage()               {}
func (*GenericResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

type isGenericResponse_Reply interface {
	isGenericResponse_Reply()
}

type GenericResponse_Result_ struct {
	Result *GenericResponse_Result `protobuf:"bytes,1,opt,name=result,oneof"`
}
type GenericResponse_Error_ struct {
	Error *GenericResponse_Error `protobuf:"bytes,2,opt,name=error,oneof"`
}

func (*GenericResponse_Result_) isGenericResponse_Reply() {}
func (*GenericResponse_Error_) isGenericResponse_Reply()  {}

func (m *GenericResponse) GetReply() isGenericResponse_Reply {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *GenericResponse) GetResult() *GenericResponse_Result {
	if x, ok := m.GetReply().(*GenericResponse_Result_); ok {
		return x.Result
	}
	return nil
}

func (m *GenericResponse) GetError() *GenericResponse_Error {
	if x, ok := m.GetReply().(*GenericResponse_Error_); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GenericResponse) XXX_OneofFuncs() (func(msg proto1.Message, b *proto1.Buffer) error, func(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error), func(msg proto1.Message) (n int), []interface{}) {
	return _GenericResponse_OneofMarshaler, _GenericResponse_OneofUnmarshaler, _GenericResponse_OneofSizer, []interface{}{
		(*GenericResponse_Result_)(nil),
		(*GenericResponse_Error_)(nil),
	}
}

func _GenericResponse_OneofMarshaler(msg proto1.Message, b *proto1.Buffer) error {
	m := msg.(*GenericResponse)
	// reply
	switch x := m.Reply.(type) {
	case *GenericResponse_Result_:
		b.EncodeVarint(1<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Result); err != nil {
			return err
		}
	case *GenericResponse_Error_:
		b.EncodeVarint(2<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GenericResponse.Reply has unexpected type %T", x)
	}
	return nil
}

func _GenericResponse_OneofUnmarshaler(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error) {
	m := msg.(*GenericResponse)
	switch tag {
	case 1: // reply.result
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(GenericResponse_Result)
		err := b.DecodeMessage(msg)
		m.Reply = &GenericResponse_Result_{msg}
		return true, err
	case 2: // reply.error
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(GenericResponse_Error)
		err := b.DecodeMessage(msg)
		m.Reply = &GenericResponse_Error_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GenericResponse_OneofSizer(msg proto1.Message) (n int) {
	m := msg.(*GenericResponse)
	// reply
	switch x := m.Reply.(type) {
	case *GenericResponse_Result_:
		s := proto1.Size(x.Result)
		n += proto1.SizeVarint(1<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *GenericResponse_Error_:
		s := proto1.Size(x.Error)
		n += proto1.SizeVarint(2<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type GenericResponse_Result struct {
	Message string `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
}

func (m *GenericResponse_Result) Reset()                    { *m = GenericResponse_Result{} }
func (m *GenericResponse_Result) String() string            { return proto1.CompactTextString(m) }
func (*GenericResponse_Result) ProtoMessage()               {}
func (*GenericResponse_Result) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14, 0} }

func (m *GenericResponse_Result) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type GenericResponse_Error struct {
	Code        string `protobuf:"bytes,1,opt,name=code" json:"code,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
}

func (m *GenericResponse_Error) Reset()                    { *m = GenericResponse_Error{} }
func (m *GenericResponse_Error) String() string            { return proto1.CompactTextString(m) }
func (*GenericResponse_Error) ProtoMessage()               {}
func (*GenericResponse_Error) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14, 1} }

func (m *GenericResponse_Error) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *GenericResponse_Error) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func init() {
	proto1.RegisterType((*CreateVolumeOpts)(nil), "proto.CreateVolumeOpts")
	proto1.RegisterType((*DeleteVolumeOpts)(nil), "proto.DeleteVolumeOpts")
	proto1.RegisterType((*ExtendVolumeOpts)(nil), "proto.ExtendVolumeOpts")
	proto1.RegisterType((*CreateVolumeSnapshotOpts)(nil), "proto.CreateVolumeSnapshotOpts")
	proto1.RegisterType((*DeleteVolumeSnapshotOpts)(nil), "proto.DeleteVolumeSnapshotOpts")
	proto1.RegisterType((*CreateAttachmentOpts)(nil), "proto.CreateAttachmentOpts")
	proto1.RegisterType((*DeleteAttachmentOpts)(nil), "proto.DeleteAttachmentOpts")
	proto1.RegisterType((*HostInfo)(nil), "proto.HostInfo")
	proto1.RegisterType((*VolumeData)(nil), "proto.VolumeData")
	proto1.RegisterType((*CreateReplicationOpts)(nil), "proto.CreateReplicationOpts")
	proto1.RegisterType((*DeleteReplicationOpts)(nil), "proto.DeleteReplicationOpts")
	proto1.RegisterType((*EnableReplicationOpts)(nil), "proto.EnableReplicationOpts")
	proto1.RegisterType((*DisableReplicationOpts)(nil), "proto.DisableReplicationOpts")
	proto1.RegisterType((*FailoverReplicationOpts)(nil), "proto.FailoverReplicationOpts")
	proto1.RegisterType((*GenericResponse)(nil), "proto.GenericResponse")
	proto1.RegisterType((*GenericResponse_Result)(nil), "proto.GenericResponse.Result")
	proto1.RegisterType((*GenericResponse_Error)(nil), "proto.GenericResponse.Error")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Dock service

type DockClient interface {
	// Create a volume
	CreateVolume(ctx context.Context, in *CreateVolumeOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Delete a volume
	DeleteVolume(ctx context.Context, in *DeleteVolumeOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Extend a volume
	ExtendVolume(ctx context.Context, in *ExtendVolumeOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Create a volume snapshot
	CreateVolumeSnapshot(ctx context.Context, in *CreateVolumeSnapshotOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Delete a volume snapshot
	DeleteVolumeSnapshot(ctx context.Context, in *DeleteVolumeSnapshotOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Create a volume attachment
	CreateAttachment(ctx context.Context, in *CreateAttachmentOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Delete a volume attachment
	DeleteAttachment(ctx context.Context, in *DeleteAttachmentOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Create a replication
	CreateReplication(ctx context.Context, in *CreateReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Delete a replication
	DeleteReplication(ctx context.Context, in *DeleteReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Enable a replication
	EnableReplication(ctx context.Context, in *EnableReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Disable a replication
	DisableReplication(ctx context.Context, in *DisableReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Failover a replication
	FailoverReplication(ctx context.Context, in *FailoverReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error)
}

type dockClient struct {
	cc *grpc.ClientConn
}

func NewDockClient(cc *grpc.ClientConn) DockClient {
	return &dockClient{cc}
}

func (c *dockClient) CreateVolume(ctx context.Context, in *CreateVolumeOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Dock/CreateVolume", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dockClient) DeleteVolume(ctx context.Context, in *DeleteVolumeOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Dock/DeleteVolume", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dockClient) ExtendVolume(ctx context.Context, in *ExtendVolumeOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Dock/ExtendVolume", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dockClient) CreateVolumeSnapshot(ctx context.Context, in *CreateVolumeSnapshotOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Dock/CreateVolumeSnapshot", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dockClient) DeleteVolumeSnapshot(ctx context.Context, in *DeleteVolumeSnapshotOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Dock/DeleteVolumeSnapshot", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dockClient) CreateAttachment(ctx context.Context, in *CreateAttachmentOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Dock/CreateAttachment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dockClient) DeleteAttachment(ctx context.Context, in *DeleteAttachmentOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Dock/DeleteAttachment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dockClient) CreateReplication(ctx context.Context, in *CreateReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Dock/CreateReplication", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dockClient) DeleteReplication(ctx context.Context, in *DeleteReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Dock/DeleteReplication", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dockClient) EnableReplication(ctx context.Context, in *EnableReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Dock/EnableReplication", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dockClient) DisableReplication(ctx context.Context, in *DisableReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Dock/DisableReplication", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dockClient) FailoverReplication(ctx context.Context, in *FailoverReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Dock/FailoverReplication", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Dock service

type DockServer interface {
	// Create a volume
	CreateVolume(context.Context, *CreateVolumeOpts) (*GenericResponse, error)
	// Delete a volume
	DeleteVolume(context.Context, *DeleteVolumeOpts) (*GenericResponse, error)
	// Extend a volume
	ExtendVolume(context.Context, *ExtendVolumeOpts) (*GenericResponse, error)
	// Create a volume snapshot
	CreateVolumeSnapshot(context.Context, *CreateVolumeSnapshotOpts) (*GenericResponse, error)
	// Delete a volume snapshot
	DeleteVolumeSnapshot(context.Context, *DeleteVolumeSnapshotOpts) (*GenericResponse, error)
	// Create a volume attachment
	CreateAttachment(context.Context, *CreateAttachmentOpts) (*GenericResponse, error)
	// Delete a volume attachment
	DeleteAttachment(context.Context, *DeleteAttachmentOpts) (*GenericResponse, error)
	// Create a replication
	CreateReplication(context.Context, *CreateReplicationOpts) (*GenericResponse, error)
	// Delete a replication
	DeleteReplication(context.Context, *DeleteReplicationOpts) (*GenericResponse, error)
	// Enable a replication
	EnableReplication(context.Context, *EnableReplicationOpts) (*GenericResponse, error)
	// Disable a replication
	DisableReplication(context.Context, *DisableReplicationOpts) (*GenericResponse, error)
	// Failover a replication
	FailoverReplication(context.Context, *FailoverReplicationOpts) (*GenericResponse, error)
}

func RegisterDockServer(s *grpc.Server, srv DockServer) {
	s.RegisterService(&_Dock_serviceDesc, srv)
}

func _Dock_CreateVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVolumeOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DockServer).CreateVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Dock/CreateVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DockServer).CreateVolume(ctx, req.(*CreateVolumeOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dock_DeleteVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVolumeOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DockServer).DeleteVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Dock/DeleteVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DockServer).DeleteVolume(ctx, req.(*DeleteVolumeOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dock_ExtendVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExtendVolumeOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DockServer).ExtendVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Dock/ExtendVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DockServer).ExtendVolume(ctx, req.(*ExtendVolumeOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dock_CreateVolumeSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVolumeSnapshotOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DockServer).CreateVolumeSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Dock/CreateVolumeSnapshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DockServer).CreateVolumeSnapshot(ctx, req.(*CreateVolumeSnapshotOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dock_DeleteVolumeSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVolumeSnapshotOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DockServer).DeleteVolumeSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Dock/DeleteVolumeSnapshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DockServer).DeleteVolumeSnapshot(ctx, req.(*DeleteVolumeSnapshotOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dock_CreateAttachment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAttachmentOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DockServer).CreateAttachment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Dock/CreateAttachment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DockServer).CreateAttachment(ctx, req.(*CreateAttachmentOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dock_DeleteAttachment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAttachmentOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DockServer).DeleteAttachment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Dock/DeleteAttachment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DockServer).DeleteAttachment(ctx, req.(*DeleteAttachmentOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dock_CreateReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateReplicationOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DockServer).CreateReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Dock/CreateReplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DockServer).CreateReplication(ctx, req.(*CreateReplicationOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dock_DeleteReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteReplicationOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DockServer).DeleteReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Dock/DeleteReplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DockServer).DeleteReplication(ctx, req.(*DeleteReplicationOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dock_EnableReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableReplicationOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DockServer).EnableReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Dock/EnableReplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DockServer).EnableReplication(ctx, req.(*EnableReplicationOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dock_DisableReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableReplicationOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DockServer).DisableReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Dock/DisableReplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DockServer).DisableReplication(ctx, req.(*DisableReplicationOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dock_FailoverReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FailoverReplicationOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DockServer).FailoverReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Dock/FailoverReplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DockServer).FailoverReplication(ctx, req.(*FailoverReplicationOpts))
	}
	return interceptor(ctx, in, info, handler)
}

var _Dock_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Dock",
	HandlerType: (*DockServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateVolume",
			Handler:    _Dock_CreateVolume_Handler,
		},
		{
			MethodName: "DeleteVolume",
			Handler:    _Dock_DeleteVolume_Handler,
		},
		{
			MethodName: "ExtendVolume",
			Handler:    _Dock_ExtendVolume_Handler,
		},
		{
			MethodName: "CreateVolumeSnapshot",
			Handler:    _Dock_CreateVolumeSnapshot_Handler,
		},
		{
			MethodName: "DeleteVolumeSnapshot",
			Handler:    _Dock_DeleteVolumeSnapshot_Handler,
		},
		{
			MethodName: "CreateAttachment",
			Handler:    _Dock_CreateAttachment_Handler,
		},
		{
			MethodName: "DeleteAttachment",
			Handler:    _Dock_DeleteAttachment_Handler,
		},
		{
			MethodName: "CreateReplication",
			Handler:    _Dock_CreateReplication_Handler,
		},
		{
			MethodName: "DeleteReplication",
			Handler:    _Dock_DeleteReplication_Handler,
		},
		{
			MethodName: "EnableReplication",
			Handler:    _Dock_EnableReplication_Handler,
		},
		{
			MethodName: "DisableReplication",
			Handler:    _Dock_DisableReplication_Handler,
		},
		{
			MethodName: "FailoverReplication",
			Handler:    _Dock_FailoverReplication_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dock.proto",
}

func init() { proto1.RegisterFile("dock.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1330 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x59, 0x5b, 0x6f, 0xe3, 0x44,
	0x14, 0x6e, 0xee, 0xe9, 0x49, 0x2f, 0xe9, 0x6c, 0xdb, 0xb5, 0xb2, 0xdd, 0x52, 0xc2, 0x22, 0x95,
	0x05, 0x02, 0x0a, 0x48, 0xcb, 0x45, 0x5c, 0x5a, 0xda, 0xa5, 0x11, 0xbb, 0x74, 0xd7, 0x8b, 0xf6,
	0x81, 0xb7, 0xa9, 0x3d, 0xa5, 0xa3, 0x3a, 0x1e, 0xcb, 0x9e, 0x86, 0x0d, 0x4f, 0x08, 0x78, 0x60,
	0x79, 0xe4, 0x85, 0x57, 0xf8, 0x13, 0x48, 0x48, 0xbc, 0xf2, 0x2f, 0xf8, 0x05, 0x88, 0x47, 0x7e,
	0x00, 0xf2, 0xf8, 0x12, 0xdb, 0x71, 0xa6, 0x4e, 0xd3, 0x76, 0xb7, 0x52, 0x9e, 0xe2, 0x39, 0x73,
	0xfc, 0xcd, 0x99, 0xef, 0xcc, 0x77, 0x32, 0x9e, 0x01, 0xd0, 0x99, 0x76, 0xdc, 0xb2, 0x6c, 0xc6,
	0x19, 0x2a, 0x89, 0x9f, 0xe6, 0xef, 0x25, 0xa8, 0x7f, 0x62, 0x13, 0xcc, 0xc9, 0x63, 0x66, 0x9c,
	0x74, 0xc9, 0xbe, 0xc5, 0x1d, 0xb4, 0x00, 0x79, 0xaa, 0x2b, 0xb9, 0x8d, 0xdc, 0xe6, 0xac, 0x9a,
	0xa7, 0x3a, 0x42, 0x50, 0x34, 0x71, 0x97, 0x28, 0x79, 0x61, 0x11, 0xcf, 0xae, 0xcd, 0xa1, 0xdf,
	0x10, 0xa5, 0xb0, 0x91, 0xdb, 0x2c, 0xa8, 0xe2, 0x19, 0x6d, 0x40, 0x4d, 0x27, 0x8e, 0x66, 0x53,
	0x8b, 0x53, 0x66, 0x2a, 0x45, 0xe1, 0x1e, 0x35, 0xa1, 0x75, 0x00, 0xc7, 0xc4, 0x96, 0x73, 0xc4,
	0x78, 0x47, 0x57, 0x4a, 0xc2, 0x21, 0x62, 0x41, 0xb7, 0xa1, 0x8e, 0x7b, 0x98, 0x1a, 0xf8, 0x80,
	0x1a, 0x94, 0xf7, 0xbf, 0x64, 0x26, 0x51, 0xca, 0xc2, 0x6b, 0xc8, 0x8e, 0xd6, 0x60, 0xd6, 0xb2,
	0xd9, 0x21, 0x35, 0x48, 0x47, 0x57, 0x2a, 0xc2, 0x69, 0x60, 0x40, 0xab, 0x50, 0xb6, 0x18, 0x33,
	0x3a, 0xba, 0x52, 0x15, 0x5d, 0x7e, 0x0b, 0x35, 0xa0, 0xea, 0x3e, 0x7d, 0xee, 0xce, 0x67, 0x56,
	0xf4, 0x84, 0x6d, 0xb4, 0x05, 0xd5, 0x2e, 0xe1, 0x58, 0xc7, 0x1c, 0x2b, 0xb0, 0x51, 0xd8, 0xac,
	0xb5, 0x5f, 0xf6, 0xd8, 0x6a, 0x25, 0x29, 0x6a, 0xdd, 0xf7, 0xfd, 0x76, 0x4d, 0x6e, 0xf7, 0xd5,
	0xf0, 0x35, 0x77, 0x58, 0x97, 0xe4, 0x8e, 0xae, 0xd4, 0xbc, 0x61, 0xbd, 0x96, 0x3b, 0x71, 0xdd,
	0xa6, 0x3d, 0x62, 0x8b, 0x81, 0xe7, 0xbc, 0x89, 0x0f, 0x2c, 0x48, 0x81, 0x8a, 0xc6, 0x4c, 0x4e,
	0x9e, 0x70, 0x65, 0x5e, 0x74, 0x06, 0x4d, 0x74, 0x04, 0x2b, 0x36, 0xb1, 0x0c, 0xaa, 0x61, 0x97,
	0xc1, 0x1d, 0xf1, 0xca, 0x8e, 0x1b, 0xe1, 0x82, 0x88, 0xb0, 0x3d, 0x2a, 0x42, 0x35, 0xed, 0x25,
	0x2f, 0xdc, 0x74, 0x40, 0x74, 0x0b, 0xe6, 0x23, 0x1d, 0x1d, 0x5d, 0x59, 0x14, 0x91, 0xc4, 0x8d,
	0x8d, 0xf7, 0x61, 0x3e, 0x36, 0x79, 0x54, 0x87, 0xc2, 0x31, 0xe9, 0xfb, 0xcb, 0xc5, 0x7d, 0x44,
	0xcb, 0x50, 0xea, 0x61, 0xe3, 0x24, 0x58, 0x30, 0x5e, 0xe3, 0xbd, 0xfc, 0x3b, 0xb9, 0xc6, 0x1e,
	0x34, 0x46, 0xc7, 0x35, 0x0e, 0x52, 0xf3, 0xbf, 0x1c, 0xd4, 0x77, 0x88, 0x41, 0xa4, 0x0b, 0x37,
	0x9a, 0xd0, 0x7c, 0x2c, 0xa1, 0xc9, 0x57, 0x33, 0x24, 0xb4, 0x20, 0x49, 0x68, 0x51, 0x96, 0xd0,
	0x52, 0x2c, 0xa1, 0x13, 0x11, 0xd8, 0xfc, 0xbb, 0x00, 0xf5, 0xdd, 0x27, 0x9c, 0x98, 0xfa, 0x54,
	0xaf, 0x12, 0xbd, 0x26, 0x29, 0xba, 0x3c, 0xbd, 0x4e, 0x96, 0xde, 0x7f, 0xf2, 0xa0, 0x44, 0x95,
	0xfc, 0xc8, 0xa7, 0xfa, 0x82, 0xd3, 0xdc, 0x80, 0x6a, 0x4f, 0x8c, 0x17, 0x26, 0x39, 0x6c, 0xa3,
	0x4e, 0x84, 0xe4, 0xb2, 0x20, 0xf9, 0xf5, 0x94, 0x92, 0x13, 0x0d, 0x34, 0x03, 0xd9, 0x15, 0x09,
	0xd9, 0x55, 0x19, 0xd9, 0xb3, 0xe7, 0x48, 0xf6, 0xaf, 0x79, 0x50, 0xa2, 0x75, 0x40, 0x4a, 0x76,
	0x94, 0xa2, 0xbc, 0x84, 0xa2, 0x42, 0x8c, 0xa2, 0x51, 0xf0, 0x19, 0x28, 0x2a, 0x4a, 0x28, 0x2a,
	0xc9, 0x28, 0x2a, 0x9f, 0x23, 0x45, 0x4f, 0x0b, 0xb0, 0xec, 0xa5, 0x79, 0x8b, 0x73, 0xac, 0x1d,
	0x75, 0x89, 0x39, 0x3e, 0x3d, 0xb7, 0x60, 0x5e, 0x67, 0xf7, 0x98, 0x86, 0x0d, 0x0f, 0x44, 0x2c,
	0xce, 0xaa, 0x1a, 0x37, 0xba, 0xe5, 0xa1, 0x7b, 0x62, 0x70, 0xfa, 0x00, 0xf3, 0x23, 0x31, 0xf9,
	0xaa, 0x3a, 0x30, 0xa0, 0x57, 0xa1, 0x7a, 0xc4, 0x1c, 0xde, 0x31, 0x0f, 0x99, 0x98, 0x7d, 0xad,
	0xbd, 0xe8, 0x53, 0xbc, 0xe7, 0x9b, 0xd5, 0xd0, 0x01, 0xed, 0x0e, 0x2d, 0xd9, 0x57, 0x62, 0x4b,
	0x36, 0x3e, 0x97, 0xab, 0xb2, 0x5c, 0xff, 0xca, 0xc3, 0xb2, 0xb7, 0x9e, 0x26, 0xc8, 0x45, 0x94,
	0xc7, 0xc2, 0x38, 0x3c, 0x16, 0x63, 0x3c, 0xa6, 0xc5, 0x91, 0x81, 0xc7, 0x92, 0x84, 0xc7, 0xb2,
	0x8c, 0xc7, 0xca, 0x39, 0xf2, 0xf8, 0x6d, 0x0e, 0xaa, 0xc1, 0x64, 0xc5, 0xdf, 0x8b, 0x81, 0xf9,
	0x21, 0xb3, 0xbb, 0xfe, 0xdb, 0x61, 0xdb, 0x8d, 0x9b, 0x39, 0x5f, 0xf4, 0xad, 0x00, 0xc3, 0x6f,
	0xb9, 0x35, 0xd6, 0xa5, 0xc8, 0xdf, 0x10, 0x88, 0x67, 0x91, 0x03, 0xcb, 0xd7, 0x6c, 0x9e, 0x5a,
	0xee, 0x6a, 0xa6, 0x26, 0xe5, 0x14, 0x73, 0x66, 0xfb, 0xd3, 0x1e, 0x18, 0x9a, 0x3d, 0x00, 0xaf,
	0x26, 0x88, 0x7d, 0xd7, 0x1b, 0x50, 0x14, 0x14, 0xe7, 0x04, 0xc5, 0x37, 0x7c, 0x8a, 0x07, 0x0e,
	0xad, 0xc1, 0xce, 0x4d, 0x38, 0x36, 0xee, 0xc0, 0xec, 0xd9, 0x36, 0x4d, 0xbf, 0x54, 0x61, 0xc5,
	0x93, 0x40, 0x64, 0x17, 0x96, 0xf9, 0xbf, 0x25, 0xf1, 0x3f, 0x52, 0x18, 0xfe, 0x1f, 0xd9, 0x84,
	0x45, 0xcb, 0xa6, 0x5d, 0x6c, 0xf7, 0x1f, 0x07, 0x0b, 0xd0, 0xa3, 0x24, 0x69, 0x46, 0xaf, 0xc1,
	0x92, 0x43, 0x34, 0x66, 0xea, 0x51, 0x5f, 0x8f, 0xa7, 0xe1, 0x8e, 0x67, 0xbc, 0xcd, 0xf8, 0x2e,
	0x07, 0x6b, 0x7e, 0xfc, 0xa9, 0x9b, 0x57, 0xa5, 0x26, 0x12, 0xf7, 0x61, 0xac, 0xc6, 0x24, 0x08,
	0x6e, 0x3d, 0x90, 0x00, 0x78, 0xb9, 0x95, 0x8e, 0x81, 0x7e, 0xcc, 0xc1, 0x7a, 0x48, 0x4c, 0x7a,
	0x18, 0x73, 0x22, 0x8c, 0x8f, 0xa5, 0x61, 0x3c, 0x92, 0x42, 0x78, 0x81, 0x9c, 0x32, 0x4e, 0x44,
	0xcf, 0xf3, 0x12, 0x3d, 0x2f, 0xc8, 0xf4, 0xbc, 0x18, 0xff, 0xc6, 0x71, 0xd5, 0xe2, 0xf8, 0x0c,
	0x29, 0x75, 0xaf, 0xf6, 0x87, 0x06, 0x74, 0x37, 0x52, 0x86, 0x96, 0xc4, 0x1c, 0x6f, 0x4b, 0xe7,
	0x38, 0xaa, 0x0e, 0xbd, 0x0b, 0x0b, 0xbd, 0x50, 0x54, 0xf7, 0xa8, 0xc3, 0x15, 0x24, 0xd0, 0x96,
	0x86, 0x14, 0xa7, 0x26, 0x1c, 0x1b, 0xfb, 0xf0, 0xe2, 0xa9, 0x09, 0x1c, 0xeb, 0x43, 0xe8, 0x21,
	0xbc, 0x94, 0x21, 0x15, 0x63, 0x41, 0x4e, 0x54, 0x14, 0xff, 0x28, 0xc3, 0x8a, 0x57, 0xd4, 0xa7,
	0x95, 0xe1, 0xc2, 0x2a, 0x43, 0x2a, 0xc1, 0x97, 0x5f, 0x19, 0xd2, 0xc3, 0x78, 0x2e, 0x2b, 0xc3,
	0x55, 0x10, 0x9e, 0xd0, 0xce, 0xae, 0x89, 0x0f, 0x8c, 0xa9, 0x76, 0x2e, 0x4e, 0x3b, 0xa9, 0x04,
	0x5f, 0xbe, 0x76, 0xd2, 0xc3, 0x98, 0x6a, 0xe7, 0xac, 0xda, 0xf9, 0xb3, 0x0c, 0xab, 0x3b, 0xd4,
	0x99, 0x8a, 0x67, 0x3c, 0xf1, 0x7c, 0x9f, 0x4d, 0x3c, 0x1f, 0x05, 0x15, 0x3f, 0x95, 0xe1, 0x89,
	0xd5, 0xf3, 0x34, 0xab, 0x7a, 0xb6, 0xe4, 0x71, 0x4c, 0xe5, 0x73, 0x56, 0xf9, 0xfc, 0x56, 0x81,
	0xeb, 0x77, 0x31, 0x35, 0x58, 0x8f, 0xd8, 0x53, 0xfd, 0x64, 0xd7, 0xcf, 0x0f, 0xd9, 0xf4, 0x13,
	0x54, 0xfd, 0x11, 0x14, 0x4f, 0x2c, 0xa0, 0x9f, 0xb2, 0x0a, 0x68, 0xfb, 0x94, 0x40, 0x9e, 0xcf,
	0xcf, 0xba, 0x37, 0xe1, 0x1a, 0x36, 0x0c, 0xf6, 0xb5, 0x77, 0x4e, 0x44, 0xfc, 0xf3, 0x78, 0xff,
	0x03, 0x2f, 0xad, 0x0b, 0xb5, 0x00, 0x85, 0x51, 0x6e, 0x63, 0xed, 0x98, 0x98, 0x7a, 0x47, 0x57,
	0x96, 0x04, 0x6c, 0x4a, 0xcf, 0x95, 0xd0, 0xe8, 0xbf, 0x39, 0x58, 0xfc, 0x94, 0x98, 0xc4, 0xa6,
	0x9a, 0x4a, 0x1c, 0x8b, 0x99, 0x0e, 0x41, 0x77, 0xa0, 0x6c, 0x13, 0xe7, 0xc4, 0xe0, 0x02, 0xa2,
	0xd6, 0xbe, 0xe9, 0xe7, 0x37, 0xe1, 0xd7, 0x52, 0x85, 0xd3, 0xde, 0x8c, 0xea, 0xbb, 0xa3, 0xb7,
	0xa1, 0x44, 0x6c, 0x9b, 0xd9, 0x62, 0x98, 0x5a, 0x7b, 0x6d, 0xc4, 0x7b, 0xbb, 0xae, 0xcf, 0xde,
	0x8c, 0xea, 0x39, 0x37, 0x9a, 0x50, 0xf6, 0x90, 0xdc, 0x64, 0x75, 0x89, 0xe3, 0xe0, 0xaf, 0x88,
	0x1f, 0x7c, 0xd0, 0x6c, 0x7c, 0x00, 0x25, 0xf1, 0x96, 0x5b, 0x27, 0x34, 0xa6, 0x07, 0xfd, 0xe2,
	0x39, 0x59, 0x27, 0xf2, 0x43, 0x75, 0x62, 0xbb, 0x02, 0x25, 0x9b, 0x58, 0x46, 0xbf, 0xfd, 0x73,
	0x05, 0x8a, 0x3b, 0x4c, 0x3b, 0x46, 0x5b, 0x30, 0x17, 0xbd, 0x21, 0x40, 0xd7, 0x47, 0xdc, 0x54,
	0x36, 0x56, 0xd3, 0x27, 0xd1, 0x9c, 0x71, 0x21, 0xa2, 0x27, 0xe8, 0x21, 0x44, 0xf2, 0xf6, 0x4e,
	0x0e, 0x11, 0xbd, 0x0c, 0x0a, 0x21, 0x92, 0x37, 0x44, 0x12, 0x88, 0x87, 0xc1, 0x19, 0x78, 0xfc,
	0x1c, 0x1f, 0xbd, 0x70, 0xca, 0x3d, 0x88, 0x1c, 0x32, 0xed, 0x6a, 0x20, 0x84, 0x1c, 0x75, 0x6f,
	0x20, 0x81, 0xec, 0x04, 0x17, 0xf9, 0x83, 0x53, 0x59, 0x74, 0x43, 0x72, 0xec, 0x2d, 0x87, 0x4a,
	0x1e, 0xf0, 0x86, 0x50, 0x69, 0x27, 0xbf, 0x12, 0xa8, 0xcf, 0x60, 0x69, 0xe8, 0x90, 0x06, 0xad,
	0xc9, 0x8e, 0x6f, 0xe4, 0x60, 0x43, 0xdf, 0xae, 0x21, 0x58, 0xea, 0x57, 0xad, 0x1c, 0x6c, 0x68,
	0x33, 0x1f, 0x82, 0xa5, 0x6e, 0xf3, 0x25, 0x60, 0xf7, 0x01, 0x0d, 0xef, 0x6d, 0xd0, 0x4d, 0xe9,
	0xb6, 0x47, 0x02, 0xb7, 0x0f, 0xd7, 0x52, 0x2a, 0x3d, 0x5a, 0x97, 0xff, 0x0b, 0x8c, 0x06, 0x3c,
	0x28, 0x8b, 0x8e, 0xb7, 0xfe, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x3e, 0x61, 0x1a, 0x62, 0x02, 0x22,
	0x00, 0x00,
}
